<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL Binlog详解</title>
      <link href="2022/03/25/2022-03-25-mysql-binlog/"/>
      <url>2022/03/25/2022-03-25-mysql-binlog/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL-Binlog"><a href="#MySQL-Binlog" class="headerlink" title="MySQL Binlog"></a>MySQL Binlog</h2><blockquote><p>MySQL 的 Binlog 日志是一种二进制格式的日志，Binlog 记录所有的 DDL 和 DML 语句(除了数据查询语句SELECT、SHOW等)，以 Event 的形式记录，同时记录语句执行时间。</p></blockquote><p>Binlog 包括两类文件：</p><ul><li>二进制日志索引文件(.index)：记录所有的二进制文件。</li><li>二进制日志文件(.00000*)：记录所有 DDL 和 DML 语句事件。</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li><p><strong>数据恢复</strong></p><p>因为 Binlog 详细记录了所有修改数据的 SQL，当某一时刻的数据误操作而导致出问题，或者数据库宕机数据丢失，那么可以根据 Binlog 来回放历史数据。</p></li><li><p><strong>主从复制</strong></p><p>想要做多机备份的业务，可以去监听当前写库的 Binlog 日志，同步写库的所有更改。</p></li></ol><h3 id="MySQL-Binlog配置"><a href="#MySQL-Binlog配置" class="headerlink" title="MySQL Binlog配置"></a>MySQL Binlog配置</h3><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">设置此参数表示启用binlog功能，并制定二进制日志的存储目录<span class="token attr-name">log-bin</span><span class="token punctuation">=</span><span class="token attr-value">/home/mysql/binlog/</span><span class="token comment">#mysql-bin.*日志文件最大字节（单位：字节）</span><span class="token comment">#设置最大100MB</span><span class="token attr-name">max_binlog_size</span><span class="token punctuation">=</span><span class="token attr-value">104857600</span><span class="token comment">#设置了只保留7天BINLOG（单位：天）</span><span class="token attr-name">expire_logs_days</span> <span class="token punctuation">=</span> <span class="token attr-value">7</span><span class="token comment">#binlog日志只记录指定库的更新</span><span class="token comment">#binlog-do-db=db_name</span><span class="token comment">#binlog日志不记录指定库的更新</span><span class="token comment">#binlog-ignore-db=db_name</span><span class="token comment">#写缓冲多少次，刷一次磁盘，默认0</span><span class="token attr-name">sync_binlog</span><span class="token punctuation">=</span><span class="token attr-value">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>max_binlog_size</strong> ：Binlog 最大和默认值是 1G，该设置并不能严格控制 Binlog 的大小，尤其是 Binlog 比较靠近最大值而又遇到一个比较大事务时，为了保证事务的完整性不可能做切换日志的动作，只能将该事务的所有 SQL 都记录进当前日志直到事务结束。所以真实文件有时候会大于 max_binlog_size 设定值。<br><strong>expire_logs_days</strong> ：Binlog 过期删除不是服务定时执行，是需要借助事件触发才执行，事件包括：</p><ul><li>服务器重启</li><li>服务器被更新</li><li>日志达到了最大日志长度 <code>max_binlog_size</code></li><li>日志被刷新</li></ul><p>二进制日志由配置文件的 <code>log-bin</code> 选项负责启用，MySQL 服务器将在数据根目录创建两个新文件<code>mysql-bin.000001</code> 和 <code>mysql-bin.index</code>，若配置选项没有给出文件名，MySQL 将使用主机名称命名这两个文件，其中 <code>.index</code> 文件包含一份全体日志文件的清单。</p><p><strong>sync_binlog</strong>：这个参数决定了 Binlog 日志的更新频率。默认 0 ，表示该操作由操作系统根据自身负载自行决定多久写一次磁盘。</p><p>sync_binlog = 1 表示每一条事务提交都会立刻写盘。sync_binlog=n 表示 n 个事务提交才会写盘。</p><p><strong>根据 MySQL 文档，写 Binlog 的时机是：SQL transaction 执行完，但任何相关的 Locks 还未释放或事务还未最终 commit 前。这样保证了 Binlog 记录的操作时序与数据库实际的数据变更顺序一致。</strong></p></li></ul><h3 id="Binlog-日志格式"><a href="#Binlog-日志格式" class="headerlink" title="Binlog 日志格式"></a>Binlog 日志格式</h3><p>针对不同的使用场景，Binlog 也提供了可定制化的服务，提供了三种模式来提供不同详细程度的日志内容。</p><ul><li>Statement 模式：基于 SQL 语句的复制(statement-based replication-SBR)</li><li>Row 模式：基于行的复制(row-based replication-RBR)</li><li>Mixed 模式：混合模式复制(mixed-based replication-MBR)</li></ul><h6 id="Statement-模式"><a href="#Statement-模式" class="headerlink" title="Statement 模式"></a>Statement 模式</h6><p>保存每一条修改数据的SQL。</p><p>该模式只保存一条普通的SQL语句，不涉及到执行的上下文信息。</p><p>因为每台 MySQL 数据库的本地环境可能不一样，那么对于依赖到本地环境的函数或者上下文处理的逻辑 SQL 去处理的时候可能同样的语句在不同的机器上执行出来的效果不一致。</p><p>比如像 <code>sleep()</code>函数，<code>last_insert_id()</code>函数，等等，这些都跟特定时间的本地环境有关。</p><h5 id="Row-模式"><a href="#Row-模式" class="headerlink" title="Row 模式"></a>Row 模式</h5><p>MySQL V5.1.5 版本开始支持Row模式的 Binlog，它与 Statement 模式的区别在于它不保存具体的 SQL 语句，而是记录具体被修改的信息。</p><p>比如一条 update 语句更新10条数据，如果是 Statement 模式那就保存一条 SQL 就够，但是 Row 模式会保存每一行分别更新了什么，有10条数据。</p><p>Row 模式的优缺点就很明显了。保存每一个更改的详细信息必然会带来存储空间的快速膨胀，换来的是事件操作的详细记录。所以要求越高代价越高。</p><h5 id="Mixed-模式"><a href="#Mixed-模式" class="headerlink" title="Mixed 模式"></a>Mixed 模式</h5><p>Mixed 模式即以上两种模式的综合体。既然上面两种模式分别走了极简和一丝不苟的极端，那是否可以区分使用场景的情况下将这两种模式综合起来呢？</p><p>在 Mixed 模式中，一般的更新语句使用 Statement 模式来保存 Binlog，但是遇到一些函数操作，可能会影响数据准确性的操作则使用 Row 模式来保存。这种方式需要根据每一条具体的 SQL 语句来区分选择哪种模式。</p><p>MySQL 从 V5.1.8 开始提供 Mixed 模式，V5.7.7 之前的版本默认是Statement 模式，之后默认使用Row模式， 但是在 8.0 以上版本已经默认使用 Mixed 模式了。</p><h3 id="通过-mysqlbinlog-命令手动恢复数据"><a href="#通过-mysqlbinlog-命令手动恢复数据" class="headerlink" title="通过 mysqlbinlog 命令手动恢复数据"></a>通过 <code>mysqlbinlog</code> 命令手动恢复数据</h3><p>如果我们当前的 MySQL 库被无操作或者误删除了，那么该如何通过 Binlog 来恢复到删除之前的数据状态呢？</p><p>首先发现误操作之后，先停止 MySQL 服务，防止继续更新。</p><p>接着通过 <code>mysqlbinlog</code>命令对二进制文件进行分析，查看误操作之前的位点信息在哪里。</p><p>接下来肯定就是恢复数据，当前数据库的数据已经是错的，那么就从开始位置到误操作之前位点的数据肯定的都是正确的；如果误操作之后也有正常的数据进来，这一段时间的位点数据也要备份。</p><p>比如说：</p><p>误操作的位点开始值为 501，误操作结束的位置为705，之后到800的位点都是正确数据。</p><p>那么从 0 - 500 ，706 - 800 都是有效数据，接着我们就可以进行数据恢复了。</p><p>先将数据库备份并清空。</p><p>接着使用 <code>mysqlbinlog</code> 来恢复数据：</p><p>0 - 500 的数据：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysqlbinlog <span class="token comment">--start-position=0  --stop-position=500  bin-log.000003 &gt; /root/back.sql;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面命令的作用就是将 0 -500 位点的数据恢复到自定义的 SQL 文件中。同理 706 - 800 的数据也是一样操作。之后我们执行这两个 SQL 文件就行了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL执行计划</title>
      <link href="2022/03/25/2022-03-25-mysql-zhi-xing-ji-hua/"/>
      <url>2022/03/25/2022-03-25-mysql-zhi-xing-ji-hua/</url>
      
        <content type="html"><![CDATA[<p>执行计划各个字段的含义如下：</p><table><thead><tr><th>列名</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>执行序号，MSYQL 会按照从大到小的顺序执行</td></tr><tr><td>select_type</td><td>查询类型：SIMPLE: 简单查询 PRIMARY: 外层查询 SUBQUERY: 子查询 DERIVED: 派生查询（FROM 中包含的子查询） UNION: UNION 中第二个或后面的那个查询 UNION RESULT: UNION 的结果</td></tr><tr><td>table</td><td>引用的表</td></tr><tr><td>partitions</td><td>所属分区</td></tr><tr><td>type</td><td>访问类型<a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-join-types">官方文档</a>，常见访问类型： system : 只有一条记录的表（=系统表） const : 通过索引一次就查询到 eq_ref : 唯一索引等值扫描 ref : 非唯一索引等值扫描 range : 范围索引扫描 index : 索引扫描 all : 全表扫描</td></tr><tr><td>possible_keys</td><td>可能使用的索引（优化前）</td></tr><tr><td>key</td><td>实际使用的索引（优化后）</td></tr><tr><td>key_len</td><td>使用索引的长度</td></tr><tr><td>ref</td><td>上述表的连接匹配条件（哪些列或常量被用于查找索引列上的值）</td></tr><tr><td>rows</td><td>必须扫描的行数</td></tr><tr><td>Extra</td><td>附加信息<a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-extra-information">官方文档</a>，常见附加信息： Using filesort : mysql 无法利用索引完成排序操作 Using temporary : 使用了临时表保存中间结果 Using index : select 操作使用了覆盖索引 Using where : 使用 where 过滤 using join buffer : 使用了连接缓存 impossible where : where 子句的值总是 false，不能用来获取任何记录 distinct : 优化 distinct，在找到第一个匹配的记录后停止扫描同样值的动作</td></tr></tbody></table><p><strong>id</strong></p><p>执行序号，id 列的编号是 select 的序列号，有几个 select 就有几个 id，并且 id 的顺序是按select 出现的顺序增长的。id 越大执行优先级越高，id 相同则从上往下执行，id 为 NULL 最后执行。</p><p><strong>key_len</strong></p><p>key_len 长度表示在索引里使用的字节数，通过这个值可以估算出具体使用了索引中的哪些列。</p><p>ken_len 计算规则如下：</p><ul><li><strong>字符串</strong> ：char(n)：n 字节长度； varchar(n)：n 字节存储字符串长度，如果是 utf-8， 则长度是 3n+2，这里的长度与字符集有直接关系；</li><li><strong>数值类型</strong>：tinyint：1 字节；smallint：2 字节 ；int：4 字节； bigint：8字节；</li><li><strong>时间类型</strong> ：date：3字节；timestamp：4字节；datetime：8字节。</li></ul><p>如果字段允许为 NULL，需要 1 字节记录是否为 NULL； 索引最大长度是 768 字节，当字符串过长时，MySQL 会做一个类似做前缀索引的处理，将前半部分的字符串提取出来做索引。</p><p><strong>type</strong></p><p>type 显示的是访问类型，结果值从好到坏依次是：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">Copysystem &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一般来说，得保证查询至少达到 range 级别，最好能达到 ref。</p><p>下面对这几个类型简要说明：</p><ul><li><p><em>system</em><br>该表只有一行（如：系统表）。这是 const 连接类型的特例。</p></li><li><p><em>const</em><br>该表最多只有一个匹配行，在整个查询过程中这个表最多只会有一条匹配的行，用到了 primary key 或者unique 索引。</p><p>比如主键查询肯定只有一条记录被匹配到。</p></li><li><p><em>eq_ref</em><br>对于前面表格中的每个行组合，从该表中读取一行。除了 system 和 const 类型之外，这是最好的连接类型。当连接使用索引的所有部分且索引是 索引 <code>PRIMARY KEY</code> 或 <code>UNIQUE NOT NULL</code> 索引时使用它。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CopySELECT <span class="token operator">*</span> <span class="token keyword">FROM</span> ref_table<span class="token punctuation">,</span>other_table <span class="token keyword">WHERE</span> ref_table<span class="token punctuation">.</span>key_column<span class="token operator">=</span>other_table<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><em>ref</em><br>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</p></li><li><p><em>fulltext</em><br>使用 FULLTEXT 索引执行连接。</p></li><li><p><em>ref_or_null</em></p><p>该连接类型如同 ref，但是添加了 MySQL 可以专门搜索包含 NULL 值的行。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CopySELECT <span class="token operator">*</span> <span class="token keyword">FROM</span> ref_table <span class="token keyword">WHERE</span> key_column <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><em>index_merge</em><br>该连接类型表示使用了索引合并优化方法。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CopySELECT <span class="token operator">*</span> <span class="token keyword">FROM</span> tbl_name <span class="token keyword">WHERE</span> key1 <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">OR</span> key2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tbl_name<span class="token keyword">WHERE</span> <span class="token punctuation">(</span>key1 <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">OR</span> key2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">AND</span> non_key <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><em>unique_subquery</em><br>此类型替换 以下形式的 eq_ref 某些 IN子查询：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">Copyvalue <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> primary_key <span class="token keyword">FROM</span> single_table <span class="token keyword">WHERE</span> some_expr<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><em>index_subquery</em><br>此连接类型类似于 unique_subquery。它替换 IN 子查询，但它适用于以下形式的子查询中的非唯一索引：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">Copyvalue <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> key_column <span class="token keyword">FROM</span> single_table <span class="token keyword">WHERE</span> some_expr<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><em>range</em><br>给定范围内的检索，使用一个索引来检查行。通常发生在在索引列上使用范围查询，如 &gt;，&lt;，in 等时，非索引列是 ALL。</p></li><li><p><em>index</em><br>按索引次序扫描，先读索引，再读实际的行，结果也是全表扫描，主要优点是避免了排序。（索引是排好序的，并且 all 是从硬盘中读的，index 可能不在硬盘上。s</p></li><li><p><em>ALL</em><br>对前面表格中的每个行组合进行全表扫描。如果表是第一个未标记的表 const，通常不好，并且在所有其他情况下通常 非常糟糕。通常，您可以ALL通过添加基于常量值或早期表中的列值从表中启用行检索的索引来避免</p></li></ul><p><strong>row</strong></p><p>这一列是 MYSQL 估计要读取并检测的行数，注意这个不是结果集的行数。</p><p><strong>Extra</strong></p><p>Extra 是 EXPLAIN 输出中另外一个很重要的列，该列显示 MySQL 在查询过程中的一些详细信息。</p><ul><li><em>Distinct</em>：MySQL 发现第 1 个匹配行后，停止为当前的行组合搜索更多的行。</li><li><em>Not exists</em>：MySQL 能够对查询进行 LEFT JOIN 优化，发现1个匹配 LEFT JOIN 标准的行后，不再为前面的的行组合在该表内检查更多的行。</li><li><em>range checked for each record</em>：MySQL 没有发现好的可以使用的索引，但发现如果来自前面的表的列值已知。可能部分索引可以使用。</li><li><em>Using filesort</em>：<strong>看到这个的时候，查询就需要优化了。MySQL 需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行。</strong></li><li><em>Using index</em>：从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。</li><li><em>Using temporary</em>：<strong>为了解决查询，MySQL 需要创建一个临时表来容纳结果。看到这个就需要进行优化了，这通常发生在对不同的列集进行 order by 上，而不是 group by 上。</strong></li><li><em>Using where</em>：WHERE 子句用于限制哪一个行匹配下一个表或发送到客户。</li><li><em>Using sort_union| Using union|Using intersect</em>：这些函数说明如何为 index_merge 联接类型合并索引扫描。</li><li><em>Using index for group-by</em>：类似于访问表的 Using index 方式，Using index for group-by 表示 MySQL 发现了一个索引，可以用来查询 GROUP BY 或 DISTINCT 查询的所有列，而不要额外搜索硬盘访问实际的表。</li></ul><p>了解了执行计划，当你不确定一条 sql 查询效率的时候 就可以使用 Explain 来查看。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis主从同步原理</title>
      <link href="2022/03/25/2022-03-25-redis-zhu-cong-tong-bu-yuan-li/"/>
      <url>2022/03/25/2022-03-25-redis-zhu-cong-tong-bu-yuan-li/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis主从同步"><a href="#Redis主从同步" class="headerlink" title="Redis主从同步"></a>Redis主从同步</h3><blockquote><p>Redis Replication是一种简单、易用的主从模式（master-slave）的复制机制，它能够使得slave节点成为与master节点完全相同的副本。每次与master节点连接中断后slave节点会自动重联，并且无论master节点发生什么，slave节点总是尝试达到与master节点一致的状态。Redis采取了一系列的辅助措施来保证数据安全。</p></blockquote><p>Redis2.8版本之前，每次slave节点断线重联后，只能进行全量同步。在2.8版本之后进行了重新设计，引入了部分同步的概念。</p><p>主从复制机制包含三个部分：全量同步、部分同步、命令传播。</p><h4 id="主从同步的几个重要参数"><a href="#主从同步的几个重要参数" class="headerlink" title="主从同步的几个重要参数"></a>主从同步的几个重要参数</h4><ul><li><strong>Replication ID</strong>（复制ID或masterId）：每个Redis的主节点都用一个随机生成的字符串来表示在某一时刻其内部存储数据的状态，“某一时刻”可以理解为其成为master角色的那一刻，由源码可知在第一个从节点加入时，Redis初始化了复制ID。</li><li><strong>offset</strong>（复制偏移量）：主从模式下，主节点会持续不断的向从节点传播引起数据集更改的命令，offset所表示的是主节点向从节点传递命令字节总数。它不是孤立存在的，需要配合复制积压缓冲区才能工作。</li><li><strong>backlog</strong>（复制积压缓冲区）：它是一个<strong>环形</strong>缓冲区，用来存储主节点向从节点传递的命令，它的大小是固定的，可存储的命令有限，超出部分将会被删除。它即可用于部分同步，也可用于命令传播阶段的命令重推。</li></ul><h4 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h4><blockquote><p>master节点创建全量数据的RDB快照文件，通过网络连接发送给slave节点，slave节点加载快照文件恢复数据，然后再继续发送复制过程中复制积压缓冲区内新增的命令，使之达到数据一致状态。</p></blockquote><ul><li>从节点与主节点建立连接后，需要从节点使用命令<code>PSYNC &lt;replid&gt; &lt;offset&gt;</code>向主节点发起同步请求，从节点会从<code>server.cache_master</code>中取出两个参数构建命令，然后发给主节点。注意：如果该从节点是全新的，从未与任何主节点进行主从复制，那么会使用特殊的命令：<code>PSYNC ? -1</code>。</li><li>主节点接收到命令，解析请求中的复制ID和offset，然后去判断当前请求是否可以使用部分同步。</li><li>能够使用部分同步需要满足以下两个条件（<strong>这里先不考虑主从切换导致的多复制ID情况</strong>）：<ul><li>复制ID与主节点的复制ID一致；</li><li>复制偏移量offset必须在backlog_off和offset的范围之间；</li></ul></li><li>不能使用部分同步，就不得不使用全量同步了。</li></ul><h4 id="部分同步"><a href="#部分同步" class="headerlink" title="部分同步"></a>部分同步</h4><p>部分同步其实是以全量同步为基础（得到复制ID），用复制积压缓冲区中的缓存命令做命令重放的增量同步逻辑，不过受制于复制积压缓冲区的容量，它可容忍的范围是有限的。这与持久化机制的AOF混合持久化如出一辙，也与mysql中主从复制的Binlog思路不谋而合。</p><h4 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h4><blockquote><p>如果master-slave节点保持连接，master节点将持续向slave节点发送命令流，以保证master节点数据集发生的改变同样作用在slave节点数据集上，这些命令包含：客户端写请求、key过期、数据淘汰以及其他所有引起数据集变更的操作。</p></blockquote><p>当完成同步操作之后，master-slave便会进入命令传播阶段，此时master-slave的数据是一致的。</p><p>当maste执行完新的写命令后，会通过传播程序把该命令追加至复制积压缓冲区，然后异步地发送给slave。slave接收命令并执行，同时更新slave维护的复制偏移量offset。</p><p>如果slave可以收到每条传播指令，并执行成功，便可以保持与master的数据一致状态。但是master并不等待slave节点的返回，master与slave是通过网络通信，由于网络抖动等因素，命令传播过程不保证slave真正接收到，那如何在传播阶段确保主从数据一致呢？</p><p><strong>在命令传播阶段，每隔一秒，slave节点向master节点发送一次心跳信息，命令格式为<code>REPLCONF ACK &lt;offset&gt;</code>。</strong></p><p>命令中的offset是就是slave最新的复制偏移量，master接收后便会与自己的offset对比。<strong>如果从节点数据缺失，主节点会推送缺失的数据</strong></p><h4 id="确定同步方式"><a href="#确定同步方式" class="headerlink" title="确定同步方式"></a>确定同步方式</h4><p>该阶段首先要做的就是master-slave共同协作确定同步的方式，简单来说就是两步：slave发送PSYNC命令、master判断决定同步方式进行回复。</p><p><strong>slave发送PSYNC指令。</strong> PSYNC命令要为参数replid和offset赋值，这里需要区分两种情况：</p><ul><li>如果slave是第一次与当前master进行主从复制，则使用默认值：<code>replid=?; offset=-1</code>；</li><li>如果slave之前与该master进行过全量复制，则根据缓存的master信息、复制偏移量进行赋值；</li></ul><blockquote><p>怎么判断slave是第一次进行主从复制呢？<br>Redis核心结构server的<code>cached_master</code>保存了master节点的信息，只有进行过主从复制才会赋值，否则为空。</p></blockquote><ul><li>offset解析失败，执行全量同步；</li><li>replid与master的复制ID不一致，执行全量同步；</li><li>offset不在master的backlog缓冲区范围内，执行全量同步；</li><li>其余满足部分同步条件，执行部分同步；</li></ul><h4 id="全量同步流程"><a href="#全量同步流程" class="headerlink" title="全量同步流程"></a>全量同步流程</h4><h5 id="master侧"><a href="#master侧" class="headerlink" title="master侧"></a>master侧</h5><ul><li>修改当前slave的复制状态为<code>SLAVE_STATE_WAIT_BGSAVE_START</code>（等待bgsave操作开始）并把它加入从机列表；</li><li>如果当前slave是第一个从机，需要生成新的Replication ID、清除Replication ID2、初始化复制积压缓冲区；</li><li>开始执行bgsave，slave对应的bgsave流程开始后，其复制状态会修改为<code>SLAVE_STATE_WAIT_BGSAVE_END</code>，需要考虑以下三种情况：<ul><li>如果已经有子进程在执行，并且为磁盘模式：复用当前的bgsave，保存缓冲区状态；然后向slave回复全量同步，offset为正在进行bgsave启动时的复制偏移量；</li><li>如果已经有子进程在进行，但是为无盘模式：暂时不执行bgsave，等待周期性检查时触发；</li><li>如果没有子进程在进行：开启bgsave；然后向slave回复全量同步，offset为当前master的复制偏移量。</li></ul></li><li>master执行bgsave后就去处理别的请求了，bgsave执行成功后会在serverCron中触发<code>backgroundSaveDoneHandler</code>，进而调用<code>updateSlavesWaitingBgsave</code>，它做的事情就是依次向所有复制状态为<code>SLAVE_STATE_WAIT_BGSAVE_END</code>的slave传输rdb文件。rdb传输之前修改slave复制状态为<code>SLAVE_STATE_SEND_BULK</code>，传输完成后修改状态为<code>SLAVE_STATE_ONLINE</code>。</li></ul><h5 id="slave侧"><a href="#slave侧" class="headerlink" title="slave侧"></a>slave侧</h5><p> 在准备阶段，slave发送psync指令后，就等待master的回复，当收到全量同步的回复后，开始执行全量同步流程。过程如下：</p><ul><li>如果slave还有级联的slave，则断开所有与它们的网络链接，并清空复制积压缓冲区；</li><li>创建rdb临时文件，接收master传输的文件流并写入；</li><li>停止正在进行的rdb持久化、aof持久化流程；</li><li>重命名临时文件为正式的rdb文件，执行数据加载；</li><li>基于当前与master的网络链接，创建slave的客户端，把master作为slave的客户端；</li><li>设置slave的复制id，创建复制积压缓冲区；</li><li>进入命令传播阶段；</li></ul><h5 id="部分同步流程"><a href="#部分同步流程" class="headerlink" title="部分同步流程"></a>部分同步流程</h5><p>相对于全量同步，部分同步要简单的多。</p><p>master判定可以使用部分同步方式，执行以下流程：</p><ul><li>修改slave状态为<code>SLAVE_STATE_ONLINE</code>，并把slave加入从机列表；</li><li>向slave回复部分同步命令，”+CONTINUE replid”；</li><li>按照slave请求的offset，从复制积压缓冲区提取命令发送至slave；</li></ul><p>slave接收到部分同步的回复后，执行以下流程：</p><ul><li>对比master复制ID是否发生改变，如果改变了，则更新复制ID，并把原来的复制ID转移至复制ID2；如果有级联的slave，需要断开连接，让他们重连；</li><li>基于当前与master的连接，创建slave的客户端，准备接收命令。</li><li>接收master传输的命令并执行；</li><li>进入命令传播阶段。</li></ul><h3 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h3><h4 id="从机只读"><a href="#从机只读" class="headerlink" title="从机只读"></a>从机只读</h4><p>默认情况下，从机工作在只读模式下，即无法对从机执行写指令。如下图，对从机执行写指令将会返回错误。</p><p>若要该更此模式，可在配置文件修改如下选项：</p><pre class="line-numbers language-gams" data-language="gams"><code class="language-gams"># 默认是yes-只读，no-可写slave-read-only yes/no <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果slave也配置了自己的从服务器（sub-slave），那么sub-slave只会同步从master服务器同步到slave的数据，而不会同步我们直接写入slave服务器的数据。如：<code>A---&gt;B---&gt;C</code>，如果B关闭了只读模式，C只会同步来自A的命令且与A保持一致。</p><h4 id="过期key处理"><a href="#过期key处理" class="headerlink" title="过期key处理"></a>过期key处理</h4><p>Redis可以通过设置key的过期时间来限制key的生存时间，Redis处理key过期有惰性删除和定期删除两种机制，这一机制依赖Redis实例的计时能力。如果主机、从机同时启用key过期的处理机制，可能会导致一些问题。为此，Redis采取了三个技术手段来解决key过期的问题：</p><ul><li>从机禁用主动key过期机制。主机在执行key过期后，会以<code>DEL</code>指令的方式向所有从机传播指令，从而保证从机移除过期的key。</li><li>依赖主机的key过期机制是无法做到实时性的，所以针对读操作，从机将会按照自己的时钟向客户端返回key不存在。</li><li>为防止Lua脚本执行期间key过期，Lua脚本将会传播给从机执行。</li></ul><h4 id="min-replica机制"><a href="#min-replica机制" class="headerlink" title="min-replica机制"></a>min-replica机制</h4><p>Redis主从复制不仅仅是解决主机、从机之间数据同步的问题，它还需要保证数据的安全性。这里的安全性主要是指主从之间数据同步达到一致的效率，以及主从结构下读写分离场景中分布式系统的可靠性。</p><p>Redis采用异步复制机制，它无法真正保证每个从机都能准确的收到传播的指令，所以主从之间必然会存在命令丢失的时间窗口。</p><p>为此，Redis引入了<code>min-replicas</code>选项，该机制在redis.conf中有两个配置项：</p><ul><li>min-replicas-to-write <number of="" replicas="">：至少有N个从机才能写入数据。保证从机最低数量。</number></li><li>min-replicas-max-lag <number of="" seconds="">：如果每个从机的延迟值大于N，则拒绝写入数据。保证主从同步延迟。</number></li></ul><p>通过<code>info replication</code>可以查看从机数量（connected_slaves）、每个从机的延迟值（lat）。</p><p>这一机制是通过从机与主机之间心跳来实现的，如上文所讲，从机每隔一秒向主机发送一次心跳数据，基于心跳，主节点可以：</p><ul><li>更新从机同步确认时间：基于主节点时间及同步确认时间计算延迟值。</li><li>更新主从最后通信时间：用于从机通信超时检测，如果通信超时，主机会移除从机。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis底层数据结构</title>
      <link href="2022/03/25/2022-03-25-redis-di-ceng-shu-ju-jie-gou/"/>
      <url>2022/03/25/2022-03-25-redis-di-ceng-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h3 id="string-类型"><a href="#string-类型" class="headerlink" title="string 类型"></a>string 类型</h3><p>string 是 Redis 中最基本的数据类型，Redis 是用 C 开发的，但是 Redis 中的 string 和 C 中的 string 有很大的区别。</p><p>string 类型在 Redis 中有三种存储方式：int、raw、embstr。即 这种 string 并不是字面意义上的 string。</p><h4 id="int-格式存储"><a href="#int-格式存储" class="headerlink" title="int 格式存储"></a>int 格式存储</h4><p>当一个 key 的 value 是整型并且 value 长度不超过 20 个字符，Redis 就将其编码为 int 类型。很显然这样做是为了节约内存。</p><p>Redis 默认会缓存 10000 个整型值（<code>#define OBJSHAREDINTEGERS 10000</code>），这就意味着，如果有 10 个不同的 key，value 都是 10000 以内的值，事实上全部都是共享同一个对象。</p><h4 id="SDS-（simple-dynamic-string）"><a href="#SDS-（simple-dynamic-string）" class="headerlink" title="SDS （simple dynamic string）"></a>SDS （simple dynamic string）</h4><p>在 Redis 3.2 版本之前如果存储的是一个字符串且长度大于 39 个字节，就会使用 SDS 的格式来存储，并且将 encoding 设置为 raw。如果存储的是一个字符串但是长度小于等于 39 个字节，则将 encoding 设置为 embstr 来存储。</p><p>在 3.2 版本之后 39 被改为 44。</p><p>sds 的定义如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sdshdr</span> <span class="token punctuation">{</span>            <span class="token comment">// buf 中已占用空间的长度  </span>    <span class="token keyword">int</span> len<span class="token punctuation">;</span>        <span class="token comment">// buf 中剩余可用空间的长度  </span>    <span class="token keyword">int</span> free<span class="token punctuation">;</span>        <span class="token comment">// 数据空间  </span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字段含义：</p><ul><li>len 用于记录 buf 中已经使用的空间长度；</li><li>free 用于记录 buf 中还空余的空间（初次分配空间一般没有空余，在对字符串修改的时候，会有剩余空间出现）；</li><li>buf 字符数组，用于记录我们的字符串。</li></ul><p>当你在 Redis 存储一个 hello 时，它在 sds 中存储的结构大概如下：</p><p><img src="http://ipic-songan.oss-cn-beijing.aliyuncs.com/2022/03/19/00-09-04-5b0e18414a346fc0099f0481da234f5e-20220319000904-459ab8.png"></p><h4 id="raw-格式和-embstr-格式的区别在于："><a href="#raw-格式和-embstr-格式的区别在于：" class="headerlink" title="raw 格式和 embstr 格式的区别在于："></a><strong>raw 格式和 embstr 格式的区别在于</strong>：</h4><p>raw 编码会调用两次内存分配来分别创建 redisObject 结构和 sdshdr 结构，而 embstr 编码则通过一次内存分配函数来获得一块连续的空间，空间中依次包含 redisObject 和 sdshdr 结构。</p><p>同样对于内存释放来说，embstr 只需要一次，而 sdshdr 需要两次。</p><p>另外，因为 embstr 编码格式的字符串对象所有数据都是保存在一块连续的内存块中，那么对于查找操作来说可以将整块数据放入缓存中，更有利于读取。</p><h4 id="SDS-和-C-字符串的区别"><a href="#SDS-和-C-字符串的区别" class="headerlink" title="SDS 和 C 字符串的区别"></a><strong>SDS 和 C 字符串的区别</strong></h4><p><em>字符串长度计算</em></p><p>C 语言中的字符串使用长度为 n+1 的字符串数组来表达长度为 n 的字符串，获取字符串长度需要遍历整个数组。而 SDS 使用独立的 len 字段来记录长度。</p><p><em>C 缓冲区溢出</em></p><p>有两个在内存中紧邻的字符串”hello“ 和 ”world“，现在要把 ”hello“ 改为 ”helloo“，但是忘记重新为 ”helloo“ 分配新的内存空间，那么在 C 中会把 ”helloo“ 的位置往后溢出到后面的内存空间，即 ”world“ 的位置会被挤占。这两个单词就变为：”hellooorld”。</p><p>使用 SDS 则不用担心这种问题。Redis 会在执行修改操作之前先检查分配给 SDS 的空间是否够用，如果不够会先拓展空间再执行修改操作。</p><p><em>另外 SDS 还提供两个实用功能：空间预分配 和 惰性释放空间</em>。</p><p>预分配策略：</p><ul><li>如果修改后的 SDS 长度 &lt; 1MB，预分配同样 len 大小的空间；</li><li>如果修改后的 SDS 长度 &gt; 1MB，预分配1MB 大小的空间。</li></ul><p>缩短 SDS 空间时并不立即进行内存空间释放，而是记录 free 字节数。下次修改数据如果需要重新分配空间时优先取这一部分字节而不是重新分配。</p><h3 id="Hash-类型"><a href="#Hash-类型" class="headerlink" title="Hash 类型"></a>Hash 类型</h3><p>hash 类型的底层存储分别有两种方式：ziplist 和 hashtable。</p><h4 id="hashtable-存储"><a href="#hashtable-存储" class="headerlink" title="hashtable 存储"></a>hashtable 存储</h4><p>hashtable 实现方式我们就不细说大家都懂，基于 hash 值来实现，Redis 解决 hash 冲突使用链地址法。与 Java 中的 HashMap 不同的是，在链地址法解决冲突的过程中，对于一个冲突的 key 总是会添加到当前链表的表头而不是表尾，这样添加节点的时间复杂度就为 o(1)。</p><p>hash 的存储逻辑我们就不说，详细说一下 rehash 的过程，这个实现比较有意思。</p><p>Redis 的 字典结构体 dict 中存放了两张 hash 表：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dict</span><span class="token punctuation">{</span>    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span> <span class="token comment">//dictType结构，dictType结构中包含自定义的函数，这些函数使得key和value能够存储任何类型的数据</span>    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span> <span class="token comment">//私有数据，保存着dictType结构中函数的 参数</span>    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//两张哈希表</span>    <span class="token keyword">long</span> rehashidx<span class="token punctuation">;</span> <span class="token comment">//rehash的标记，rehashidx=-1表示没有进行rehash，rehash时每迁移一个桶就对rehashidx加一</span>    <span class="token keyword">int</span> itreators<span class="token punctuation">;</span>  <span class="token comment">//正在迭代的迭代器数量</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正常使用的就是 ht[0]，ht[1] 是只有在扩容/缩容 的时候才会用到。hash 都是有负载因子的，这里也不例外：</p><p> load factor = ht[0].used / ht[0].size</p><p>触发 rehash 有两种情况，一种是触发扩容，一种是触发缩容。</p><p>触发扩容的条件包括：</p><ul><li>服务器当前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且 load factor &gt;= 1；</li><li>服务器当前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且 load factor &gt;= 5；</li></ul><p>触发缩容的条件：</p><p>负载因子 &lt; 0.1 时（(ht[0].used / ht[0].siz) &lt; 0.1）。</p><p>再说很好玩的一点：渐进式 rehash。这个在 Java 的 HashMap 中是没有的。</p><p>所谓渐进式 rehash 即 rehash 不是一次性、集中式的完成，而是分多次、渐进式的进行。</p><p>这样做的原因在于如果 hash 表里的 KV 对很大时，比如上百万的情况如果一次性将这些数据全部从 ht[0] 移到 ht[1] 所需的庞大计算量可能会导致 Redis 在一段时间内停止服务。为了避免这种情况所以 Redis 采取了渐进式 rehash。</p><p>渐进式 rehash 期间，Redis 会逐渐的将 ht[0] 的数据转移到 ht[1] ，查找/删除/更新 操作会先查 ht[0]， 查不到会再查 ht[1]，新增操作只会在 ht[1] 上执行。</p><h4 id="zipList-存储"><a href="#zipList-存储" class="headerlink" title="zipList 存储"></a>zipList 存储</h4><p>说完 hashtable 存储我们再来说另一种存储方式：zipList。翻译过来是压缩列表，但是并不是我们理解表意上面的那种压缩。</p><p>zipList 是 list 键、 hash 键以及 zset 键的底层实现之一（3.0 之后 list 键已经不直接使用 zipList 和 linkedList 作为底层实现，取而代之的是 quickList）。</p><p>Redis 官方文档表示： zipList 是一个经过特殊编码的双向链表，这种双向链表与普通的双向链表的区别在于：<strong>它不存储上个节点和下个节点的指针，而是上个节点的长度和当前节点的长度</strong>。它的设计目标就是为了提高存储效率，zipList 适用于字段少和字段值少的场景。可用于存储字符串或整数，整数是按照二进制表示进行编码，而不是编码成字符串。</p><p>另外普通的链表中的每一项可能都不在一块连续的内存空间中，通过指针来表示数据引用。而 zipList 为了减少内存碎片率和提高查询效率，一个 zipList 对象将独自占用一块完整的独立内存空间。</p><p>下图展示了 zipList 的构成：</p><p><img src="http://ipic-songan.oss-cn-beijing.aliyuncs.com/2022/03/19/00-19-18-003b2a80617f8af83478c5954bd14267-20220319001918-434a53.png"></p><ul><li>zlbytes：32 bit，表示 zipList 占用的字节总数（也包括 zlbytes 本身占用的 4 个字节）。</li><li>zltail： 32 bit，表示 zipList 表中最后一项（entry）在 zipList 中的偏移字节数。zltail 的存在使得我们可以很方便地找到最后一项（不用遍历整个zipList ），从而可以在 zipList 尾端快速地执行 push 或 pop 操作。</li><li>zllen： 16 bit， 表示 zipList 中数据项（entry）的个数。zllen 字段因为只有 16 bit，所以可以表达的最大值为 2^16-1。这里需要特别注意的是，如果 zipList 中数据项个数超过了 16bit 能表达的最大值，zipList 仍然可以来表示。那怎么表示呢？这里做了这样的规定：如果 zllen 小于等于 216-2（也就是不等于216-1），那么 zllen 就表示 zipList 中数据项的个数；否则，也就是 zllen 等于 16bit 全为 1 的情况，那么 zllen 就不表示数据项个数了，这时候要想知道 zipList 中数据项总数，那么必须对 zipList 从头到尾遍历各个数据项才能计数出来。</li><li>entry：表示真正存放数据的数据项，长度不定。一个数据项（entry）也有它自己的内部结构。具体结构我们下面画图解释。</li><li>zlend：zipList 最后 1 个字节，是一个结束标记，值固定等于 255。</li></ul><p>再说 zipList entry 的结构：</p><p><img src="http://ipic-songan.oss-cn-beijing.aliyuncs.com/2022/03/19/00-20-35-dba1f0f8894b10b08b5b80067ad08d5c-20220319002035-eaec93.png"></p><p>pre_entry_length：根据编码方式的不同， pre_entry_length 可能占用 1 字节或者 5 字节：</p><ul><li>1 字节：如果前一节点的长度小于 254 字节，便使用一个字节保存它的值。</li><li>5 字节：如果前一节点的长度大于等于 254 字节，那么将第 1 个字节的值设为 254 ，然后用接下来的 4 个字节保存实际长度。</li></ul><p>encoding 和 length</p><p>encoding 和 length 两部分一起决定了 content 部分所保存的数据的类型（以及长度）。其中， encoding 的长度为 2 bit ， 它的值可以是 00 、 01 、 10 和 11 ：</p><ul><li>00 、 01 和 10 表示 content 部分保存着字符数组。</li><li>11 表示 content 部分保存着整数。</li></ul><p>content 部分保存着节点的内容，类型和长度由 encoding 和 length 决定。</p><p>压缩列表的本质还是一个字节数组，操作时按照既定规则将字符写入 entry 中。既然底层是一块连续的内存块那么大小肯定是有限制的， hash 结构何时使用 hashtable ，何时使用 zipList 来进行存储呢？</p><p>当我们为某个 key 第一次执行 <code>hset key field value</code> 的时候，Redis 会创建一个 hash 结构，这个新创建的 hash 结构的底层就是 zipList 结构来存储的。</p><p>随着数据插入的越多，达到 Redis 配置的默认值：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">hash<span class="token operator">-</span>max<span class="token operator">-</span>ziplist<span class="token operator">-</span>entries <span class="token number">512</span>hash<span class="token operator">-</span>max<span class="token operator">-</span>ziplist<span class="token operator">-</span>value <span class="token number">64</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>当 hash 中的数据项（即field-value对）的数目超过 512 的时候，也就是 zipList 数据项超过 1024 的时候（请参考 t_hash.c 中的 hashTypeSet 函数）。</li><li>当 hash 中插入的任意一个 value 的长度超过了 64 的时候（请参考 t_hash.c 中的 hashTypeTryConversion函数）。</li></ul><p>之所以有这两个条件限制，是因为 zipList 变大后会有几个缺点：</p><ul><li>每次插入或修改引发的 realloc 操作会有更大的概率造成内存拷贝，从而降低性能。</li><li>一旦发生内存拷贝，内存拷贝的成本也相应增加，因为要拷贝更大的一块数据，类似 COW 的复制机制。</li><li>当 zipList 数据项过多的时候，在它上面查找指定的数据项就会性能变得很低，需要遍历整个链表。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7 卸载系统自带的JDK,并安装自己需要的版本</title>
      <link href="2021/03/30/2019-05-12-centos7-xie-zai-xi-tong-zi-dai-de-jdk-bing-an-zhuang-zi-ji-xu-yao-de-ban-ben/"/>
      <url>2021/03/30/2019-05-12-centos7-xie-zai-xi-tong-zi-dai-de-jdk-bing-an-zhuang-zi-ji-xu-yao-de-ban-ben/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rpm</span> -qa <span class="token operator">|</span> <span class="token function">grep</span> java<span class="token function">rpm</span> -e --nodeps java-1.8.0-openjdk-1.8.0.181-7.b13.el7.x86_64<span class="token function">rpm</span> -e --nodeps java-1.8.0-openjdk-headless-1.8.0.181-7.b13.el7.x86_64java -version <span class="token comment">#查看已经没有jdk</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下载解压自己需要的JDK后，配置环境变量</p><p><code>vim /etc/profile </code></p><p><em>在文件中加入</em></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">export JAVA_HOME=/DATA/jdk1.7.0_80 #自己JDK的解压路径export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/libexport PATH=$JAVA_HOME/bin:$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><em>保存退出</em><br><code>source /etc/profile</code>  #使配置文件生效</p>]]></content>
      
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud中Zuul的配置</title>
      <link href="2021/03/30/2019-05-12-springcloud-zhong-zuul-de-pei-zhi/"/>
      <url>2021/03/30/2019-05-12-springcloud-zhong-zuul-de-pei-zhi/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">server:  port: 10010spring:  application:    name: api-gatewayeureka:  client:    service-url:      defaultZone: http://127.0.0.1:10086/eurekazuul:  prefix: /api # 添加路由前缀hystrix:  command:    default:      execution:        isolation:          thread:            timeoutInMillisecond: 5000 # 熔断超时时长：10000msribbon:  ConnectTimeout: 1000 # 连接超时时间(ms)  ReadTimeout: 3500 # 通信超时时间(ms)  MaxAutoRetries: 0 # 同一实例的重试次数  MaxAutoRetriesNextServer: 0 # 同一服务不同实例的重试次数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS解压版安装MySQL5.7.11</title>
      <link href="2019/05/27/2019-05-19-centosinstallmysql/"/>
      <url>2019/05/27/2019-05-19-centosinstallmysql/</url>
      
        <content type="html"><![CDATA[<h3 id="准备MySQL文件"><a href="#准备MySQL文件" class="headerlink" title="准备MySQL文件"></a>准备MySQL文件</h3><p>将下载的安装包上传到服务器</p><blockquote><p>或者使用<code>wget http://dev.MySQL.com/get/Downloads/MySQL-5.7/mysql-5.7.11-Linux-glibc2.5-x86_64.tar.gz</code> 命令在服务器在线下载,网速不好的情况不推荐,超级慢.</p></blockquote><p>解压压缩包<br><code>tar -xvf mysql-5.7.11-Linux-glibc2.5-x86_64.tar.gz</code><br>修改文件夹名字<br><code>mv mysql-5.7.11-Linux-glibc2.5-x86_64.tar.gz mysql</code></p><h3 id="新建data文件夹-用于存放数据"><a href="#新建data文件夹-用于存放数据" class="headerlink" title="新建data文件夹,用于存放数据"></a>新建data文件夹,用于存放数据</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">cd</span> mysql<span class="token comment">#data目录用于存放数据,也可以建在别的目录</span><span class="token function">mkdir</span> data <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="新建用户和用户组"><a href="#新建用户和用户组" class="headerlink" title="新建用户和用户组"></a>新建用户和用户组</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">groupadd</span> mysql<span class="token function">useradd</span> -r -g mysql -s /bin/false mysql<span class="token function">chown</span> -R root:root <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">./bin/mysqld --initialize --user<span class="token operator">=</span>mysql --basedir<span class="token operator">=</span>/data/mysql --datadir<span class="token operator">=</span>/data/mysql/data<span class="token comment">#执行完显示如下</span><span class="token comment">#centos:/data/mysql #./bin/mysqld --initialize --user=mysql --basedir=/data/mysql --datadir=/data/mysql/data</span><span class="token comment">#2019-05-27T14:06:48.121091Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).</span><span class="token comment">#2019-05-27T14:06:51.094728Z 0 [Warning] InnoDB: New log files created, LSN=45790</span><span class="token comment">#2019-05-27T14:06:51.506448Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.</span><span class="token comment">#2019-05-27T14:06:51.583755Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: ace0e20f-8088-11e9-a341-fa163ee8b7c6.</span><span class="token comment">#2019-05-27T14:06:51.585195Z 0 [Warning] Gtid table is not ready to be used. Table 'mysql.gtid_executed' cannot be opened.</span><span class="token comment">#2019-05-27T14:06:51.585726Z 1 [Note] A temporary password is generated for root@localhost: +u;jvi+%8foU</span><span class="token comment"># basedir: 就是你解压MySQL安装包路径,我这里是 /data/mysql</span><span class="token comment"># datadir: 存放数据的路径, 我这里是 /data/mysql/data</span>bin/mysql_ssl_rsa_setup --datadir<span class="token operator">=</span>/data/mysql/data<span class="token function">chown</span> -R mysql:mysql /data/mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>!!!注意这里初始化完在最后会给你 root 用户的一个默认密码,记住一下.</p></blockquote><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><blockquote><p>${MySQL解压目录}/support-files 目录下面有个 my-default.cnf ,MySQL提供的默认配置文件</p></blockquote><blockquote><p>注意:MySQL5.7.18之后不再提供这个配置文件</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">cp</span> support-files/my-default.cnf /etc/my.cnf<span class="token function">vim</span> my.cnf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>修改内容大致如下:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>client<span class="token punctuation">]</span>default-character-set <span class="token operator">=</span> utf8mb4<span class="token punctuation">[</span>mysql<span class="token punctuation">]</span>default-character-set <span class="token operator">=</span> utf8mb4<span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span>character-set-server<span class="token operator">=</span>utf8mb4<span class="token comment">#版本5.6.19以后必须设置这一句才能使[client]中设置的编码有效</span>character-set-client-handshake <span class="token operator">=</span> FALSEcollation-server<span class="token operator">=</span>utf8mb4_unicode_ci<span class="token comment">#表名是否区分大小写：1表示不区分大小写，2表示区分</span><span class="token assign-left variable">lower_case_table_names</span><span class="token operator">=</span><span class="token number">1</span>basedir <span class="token operator">=</span> /data/mysqldatadir <span class="token operator">=</span> /data/mysql/dataport <span class="token operator">=</span> <span class="token number">3306</span>socket <span class="token operator">=</span> /tmp/mysql.sock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意:这里的 basedir 和 datadir 的路径跟上面初始化数据库的地址需要一致,不然会报错</p></blockquote><h3 id="将MySQL加入服务"><a href="#将MySQL加入服务" class="headerlink" title="将MySQL加入服务"></a>将MySQL加入服务</h3><p><code>cp support-files/mysql.server /etc/init.d/mysql</code></p><h3 id="添加开机启动mysql服务"><a href="#添加开机启动mysql服务" class="headerlink" title="添加开机启动mysql服务"></a>添加开机启动mysql服务</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">chkconfig</span> --add mysql<span class="token function">chkconfig</span> --level <span class="token number">2345</span> mysql on<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="启停MySQL服务"><a href="#启停MySQL服务" class="headerlink" title="启停MySQL服务"></a>启停MySQL服务</h3><p><code>service mysql start|stop|restart|status </code></p><h3 id="登录mysql修改默认密码"><a href="#登录mysql修改默认密码" class="headerlink" title="登录mysql修改默认密码"></a>登录mysql修改默认密码</h3><p><code>./bin/mysql -uroot -p</code><br>会提示输入上面初始化数据库时给你的默认密码</p><p>修改密码:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mysql<span class="token operator">&gt;</span>set password <span class="token operator">=</span> <span class="token string">'yourpassword'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>为了方便，可以为/data/mysql/bin/mysql添加软链接到/usr/bin下，这样就可以在任意路径下使用mysql命令了：<br><code>ln -fs /data/mysql/bin/mysql /usr/bin/mysql</code></p></blockquote><h3 id="无法远程连接的解决办法"><a href="#无法远程连接的解决办法" class="headerlink" title="无法远程连接的解决办法"></a>无法远程连接的解决办法</h3><h4 id="修改mysql数据库中的user表使相应的用户能从某一主机登陆"><a href="#修改mysql数据库中的user表使相应的用户能从某一主机登陆" class="headerlink" title="修改mysql数据库中的user表使相应的用户能从某一主机登陆"></a>修改mysql数据库中的user表使相应的用户能从某一主机登陆</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mysql -u root –pmysql<span class="token operator">&gt;</span>use mysql<span class="token punctuation">;</span>mysql<span class="token operator">&gt;</span>update user <span class="token builtin class-name">set</span> <span class="token function">host</span> <span class="token operator">=</span> <span class="token string">'%'</span> where user <span class="token operator">=</span> <span class="token string">'root'</span><span class="token punctuation">;</span>mysql<span class="token operator">&gt;</span>select host, user from user<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="没有授予相应的权限"><a href="#没有授予相应的权限" class="headerlink" title="没有授予相应的权限"></a>没有授予相应的权限</h4><p>例如，你想root使用123456从任何主机连接到mysql服务器。<br><code>mysql&gt;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;</code></p><blockquote><p>123456 是连接时输入的密码.</p></blockquote><h4 id="忘记密码需要重置"><a href="#忘记密码需要重置" class="headerlink" title="忘记密码需要重置"></a>忘记密码需要重置</h4><p>修改 my.cnf 文件<br><code>vim my.cnf </code><br>在 [mysqld] 下面加入 skip-grant-tables</p><p>保存退出<br>重启MySQL服务<br><code>service mysql restart</code><br>重启之后输入#mysql即可进入mysql。<br>修改密码</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mysql<span class="token operator">&gt;</span> use mysql<span class="token punctuation">;</span>mysql<span class="token operator">&gt;</span> update user <span class="token builtin class-name">set</span> <span class="token assign-left variable">password</span><span class="token operator">=</span>password<span class="token punctuation">(</span><span class="token string">"你的新密码"</span><span class="token punctuation">)</span> where <span class="token assign-left variable">user</span><span class="token operator">=</span><span class="token string">"root"</span><span class="token punctuation">;</span>mysql<span class="token operator">&gt;</span> flush privileges<span class="token punctuation">;</span>mysql<span class="token operator">&gt;</span> quit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="遇到的一些错误"><a href="#遇到的一些错误" class="headerlink" title="遇到的一些错误"></a>遇到的一些错误</h3><ol><li><p>Starting MySQL. ERROR! The server quit without updating PID file (/xxx/centos.novalocal.pid).</p><p>看一下 xxx 目录所有者是不是mysql</p></li><li><p>初始化数据库显示 <code>./bin/mysqld: error while loading shared libraries: libaio.so.1: cannot open shared object file: No such file or directory</code></p></li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">yum -y <span class="token function">install</span> numactlyum <span class="token function">install</span>  libaio-devel.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行完这两个就ok了</p>]]></content>
      
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7使用firewalld开放端口</title>
      <link href="2019/05/19/2019-05-19-centos7usesthefirewalldopenport/"/>
      <url>2019/05/19/2019-05-19-centos7usesthefirewalldopenport/</url>
      
        <content type="html"><![CDATA[<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p><code>firewall-cmd --zone=public --add-port=6379/tcp --permanent</code></p><blockquote><p>（–permanent永久生效，没有此参数重启后失效）</p></blockquote><h3 id="重新载入"><a href="#重新载入" class="headerlink" title="重新载入"></a>重新载入</h3><p><code>firewall-cmd --reload</code></p><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><p><code>firewall-cmd --zone= public --query-port=6379/tcp</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> CentOS 7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7下Redis5.0集群搭建</title>
      <link href="2019/05/19/2019-05-19-redisclusterbuildingundercentos7/"/>
      <url>2019/05/19/2019-05-19-redisclusterbuildingundercentos7/</url>
      
        <content type="html"><![CDATA[<h1 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h1><blockquote><p>最小群集需要包含至少三个主节点,我们这里使用两台虚拟机做三主三从</p></blockquote><ol><li><p>上传Redis安装包到虚拟机</p></li><li><p>解压<code>tar xzvf redis-5.0.0.tar.gz</code> </p></li><li><p><code>cd redis-5.0.0</code></p></li><li><p>make 然后执行make install</p><blockquote><p><em><strong>(如果需要指定安装目录)</strong></em></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">cd</span> redis-5.0.0<span class="token function">make</span><span class="token builtin class-name">cd</span> src<span class="token function">make</span> <span class="token function">install</span> <span class="token assign-left variable">PREFIX</span><span class="token operator">=</span>/data/redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote></li><li><p>在 <code>/data/redis</code>下新建 <strong>conf</strong> 目录<br><code>mkdir /data/redis/conf</code></p></li></ol><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#在Redis的源码包里面(redis5.0.0/src)里面拷贝配置文件</span><span class="token function">cp</span> redis.conf /data/redis/conf/redis6379.conf<span class="token function">cp</span> redis.conf /data/redis/conf/redis6389.conf<span class="token function">cp</span> redis.conf /data/redis/conf/redis6399.conf<span class="token comment">#分别修改这三个配置文件,修改内容如下</span>port  <span class="token number">6379</span>                                        //端口6379,6389,6399        <span class="token builtin class-name">bind</span> 本机ip                                       //默认ip为127.0.0.1 需要改为其他节点机器可访问的ip 否则创建集群时无法访问对应的端口，无法创建集群daemonize    <span class="token function">yes</span>                               //redis后台运行pidfile  /var/run/redis_7000.pid          //pidfile文件对应7000,7001,7002cluster-enabled  <span class="token function">yes</span>                           //开启集群  把注释<span class="token comment">#去掉</span>cluster-config-file  nodes_7000.conf   //集群的配置  配置文件首次启动自动生成 <span class="token number">7000,7001</span>,7002cluster-node-timeout  <span class="token number">15000</span>                //请求超时  默认15秒，可自行设置appendonly  <span class="token function">yes</span>                           //aof日志开启  有需要就开启，它会每次写操作都记录一条日志　<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>在另一台虚拟机重复上面的操作(端口可以跟第一台机器一样,因为IP不同)</strong></p></blockquote><h2 id="分别启动两台虚拟机的Redis"><a href="#分别启动两台虚拟机的Redis" class="headerlink" title="分别启动两台虚拟机的Redis"></a>分别启动两台虚拟机的Redis</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#第一台虚拟机</span>./data/redis/bin/redis-server /data/redis/conf/redis6379.conf./data/redis/bin/redis-server /data/redis/conf/redis6389.conf./data/redis/bin/redis-server /data/redis/conf/redis6399.conf<span class="token comment">#第二台虚拟机</span>./data/redis/bin/redis-server /data/redis/conf/redis6379.conf./data/redis/bin/redis-server /data/redis/conf/redis6389.conf./data/redis/bin/redis-server /data/redis/conf/redis6399.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="检查-redis-启动情况"><a href="#检查-redis-启动情况" class="headerlink" title="检查 redis 启动情况"></a>检查 redis 启动情况</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#第一台虚拟机</span><span class="token punctuation">[</span>root@CentOS_Nginx data<span class="token punctuation">]</span><span class="token comment"># ps -ef |grep redis</span>root     <span class="token number">25190</span>     <span class="token number">1</span>  <span class="token number">0</span> 01:41 ?        00:00:38 ./redis-server <span class="token number">192.168</span>.199.198:6379 <span class="token punctuation">[</span>cluster<span class="token punctuation">]</span>root     <span class="token number">25195</span>     <span class="token number">1</span>  <span class="token number">0</span> 01:41 ?        00:00:35 ./redis-server <span class="token number">192.168</span>.199.198:6389 <span class="token punctuation">[</span>cluster<span class="token punctuation">]</span>root     <span class="token number">25200</span>     <span class="token number">1</span>  <span class="token number">0</span> 01:41 ?        00:00:29 ./redis-server <span class="token number">192.168</span>.199.198:6399 <span class="token punctuation">[</span>cluster<span class="token punctuation">]</span>root     <span class="token number">25571</span> <span class="token number">25435</span>  <span class="token number">0</span> 06:12 pts/2    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto redis<span class="token comment">#第二台虚拟机</span><span class="token punctuation">[</span>root@localhost bin<span class="token punctuation">]</span><span class="token comment"># ps -ef | grep redis</span>root     <span class="token number">13918</span> <span class="token number">14580</span>  <span class="token number">0</span> <span class="token number">14</span>:09 pts/0    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto redisroot     <span class="token number">19289</span>     <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">11</span>:22 ?        00:00:34 ./redis-server <span class="token number">192.168</span>.199.187:6379 <span class="token punctuation">[</span>cluster<span class="token punctuation">]</span>root     <span class="token number">19294</span>     <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">11</span>:22 ?        00:00:33 ./redis-server <span class="token number">192.168</span>.199.187:6389 <span class="token punctuation">[</span>cluster<span class="token punctuation">]</span>root     <span class="token number">19299</span>     <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">11</span>:22 ?        00:00:36 ./redis-server <span class="token number">192.168</span>.199.187:6399 <span class="token punctuation">[</span>cluster<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h1><blockquote><p>**在Redis5.0中不在使用 <code>redis-trib.rb</code> 创建集群,所以也不用再安装 Ruby **</p></blockquote><p><code>./data/redis/bin/redis-cli --cluster create 192.168.199.198:6379 192.168.199.198:6389 192.168.199.198:6399 192.168.199.187:6379 192.168.199.187:6389 192.168.199.187:6399 --cluster-replicas 1</code></p><blockquote><p>如果设置了密码,可以加上 <code>-a 密码</code> 如下:</p></blockquote><p><code>./data/redis/bin/redis-cli --cluster create 192.168.199.198:6379 192.168.199.198:6389 192.168.199.198:6399 192.168.199.187:6379 192.168.199.187:6389 192.168.199.187:6399 -a 123456 --cluster-replicas 1</code></p><p>出现如下提示:</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp21e458qij313s0pl45t.jpg"></p><p>到这集群就搭建完成了</p><h2 id="验证集群"><a href="#验证集群" class="headerlink" title="验证集群"></a>验证集群</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#登录一台Redis</span><span class="token punctuation">[</span>root@CentOS_Nginx bin<span class="token punctuation">]</span><span class="token comment"># ./redis-cli -p 6379 -h 192.168.199.198</span><span class="token number">192.168</span>.199.198:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> auth an3605958OK<span class="token number">192.168</span>.199.198:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> cluster infocluster_state:okcluster_slots_assigned:16384cluster_slots_ok:16384cluster_slots_pfail:0cluster_slots_fail:0cluster_known_nodes:6cluster_size:2cluster_current_epoch:9cluster_my_epoch:7cluster_stats_messages_ping_sent:10901cluster_stats_messages_pong_sent:10343cluster_stats_messages_meet_sent:1cluster_stats_messages_update_sent:1cluster_stats_messages_sent:21246cluster_stats_messages_ping_received:10338cluster_stats_messages_pong_received:10901cluster_stats_messages_meet_received:5cluster_stats_messages_received:21244<span class="token number">192.168</span>.199.198:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span><span class="token comment">#看到cluster_state:ok说明成功</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>还可以使用官方写好的redis-cluster脚本，进入redis根目录，里面有一个脚本（与它所包含的目录同名），它是一个简单的bash脚本。要启动具有3个主服务器和3个从服务器的6节点集群，只需键入以下命令</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">cd</span> utils/create-cluster<span class="token comment">## 启动</span>create-cluster start<span class="token comment">## 创建集群</span>create-cluster create您现在可以与群集交互，默认情况下，第一个节点将从端口30001开始，关闭命令为<span class="token comment">## 关闭</span>create-cluster stop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="整合spring-boot"><a href="#整合spring-boot" class="headerlink" title="整合spring-boot"></a>整合spring-boot</h1><h2 id="添加maven依赖"><a href="#添加maven依赖" class="headerlink" title="添加maven依赖"></a>添加maven依赖</h2><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.0.3.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在application-yml-添加Redis配置"><a href="#在application-yml-添加Redis配置" class="headerlink" title="在application.yml 添加Redis配置"></a>在application.yml 添加Redis配置</h2><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">spring:  redis:      cluster:        nodes: 192.168.199.198:6379,192.168.199.198:6389,192.168.199.198:6399,192.168.199.187:6379,192.168.199.187:6389,192.168.199.187:6399        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="添加SpringBootTest测试"><a href="#添加SpringBootTest测试" class="headerlink" title="添加SpringBootTest测试"></a>添加SpringBootTest测试</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestDemo</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span> redisTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"redis-cluster-state"</span><span class="token punctuation">,</span> <span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"redis-cluster-state"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h2><pre class="line-numbers language-text" data-language="text"><code class="language-text">2019-05-19 16:54:41.431  INFO 88393 --- [ main] io.lettuce.core.EpollProvider   : Starting without optional epoll library2019-05-19 16:54:41.433  INFO 88393 --- [ main] io.lettuce.core.KqueueProvider  : Starting without optional kqueue librarysuccess<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Conditional 派生注解</title>
      <link href="2019/05/18/2019-05-18-conditional/"/>
      <url>2019/05/18/2019-05-18-conditional/</url>
      
        <content type="html"><![CDATA[<h3 id="Conditional派生注解（Spring注解版原生的-Conditional作用）"><a href="#Conditional派生注解（Spring注解版原生的-Conditional作用）" class="headerlink" title="Conditional派生注解（Spring注解版原生的@Conditional作用）"></a>Conditional派生注解（Spring注解版原生的@Conditional作用）</h3><blockquote><p><strong>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</strong></p></blockquote><table><thead><tr><th><strong>@Conditional扩展注解</strong></th><th align="center"><strong>作用（判断是否满足当前指定条件）</strong></th></tr></thead><tbody><tr><td>@ConditionalOnJava</td><td align="center">系统的java版本是否符合要求</td></tr><tr><td>@ConditionalOnBean</td><td align="center">容器中存在指定Bean；</td></tr><tr><td>@ConditionalOnMissingBean</td><td align="center">容器中不存在指定Bean；</td></tr><tr><td>@ConditionalOnExpression</td><td align="center">满足SpEL表达式指定</td></tr><tr><td>@ConditionalOnClass</td><td align="center">系统中有指定的类</td></tr><tr><td>@ConditionalOnMissingClass</td><td align="center">系统中没有指定的类</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td align="center">容器中只有一个指定的Bean，或者这个Bean是首选Bean</td></tr><tr><td>@ConditionalOnProperty</td><td align="center">系统中指定的属性是否有指定的值</td></tr><tr><td>@ConditionalOnResource</td><td align="center">类路径下是否存在指定资源文件</td></tr><tr><td>@ConditionalOnWebApplication</td><td align="center">当前是web环境</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td align="center">当前不是web环境</td></tr><tr><td>@ConditionalOnJndi</td><td align="center">JNDI存在指定项</td></tr></tbody></table><blockquote><p><strong>自动配置类必须在一定的条件下才能生效；</strong></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 自动配置原理</title>
      <link href="2019/05/18/2019-05-18-howspringbootautomatesconfiguration/"/>
      <url>2019/05/18/2019-05-18-howspringbootautomatesconfiguration/</url>
      
        <content type="html"><![CDATA[<h2 id="自动配置原理："><a href="#自动配置原理：" class="headerlink" title="自动配置原理："></a><strong>自动配置原理：</strong></h2><h3 id="1）、SpringBoot启动的时候加载主配置类，-EnableAutoConfiguration开启了自动配置功能"><a href="#1）、SpringBoot启动的时候加载主配置类，-EnableAutoConfiguration开启了自动配置功能" class="headerlink" title="1）、SpringBoot启动的时候加载主配置类，@EnableAutoConfiguration开启了自动配置功能"></a>1）、SpringBoot启动的时候加载主配置类，<code>@EnableAutoConfiguration</code>开启了自动配置功能</h3><h3 id="2）、-EnableAutoConfiguration-作用："><a href="#2）、-EnableAutoConfiguration-作用：" class="headerlink" title="2）、@EnableAutoConfiguration 作用："></a>2）、@EnableAutoConfiguration 作用：</h3><ol><li><p>利用EnableAutoConfigurationImportSelector给容器中导入一些组件？</p></li><li><p>可以查看selectImports()方法的内容；</p></li><li><p>List<string> configurations = getCandidateConfigurations(annotationMetadata,      attributes);获取候选的配置</string></p></li></ol><pre class="line-numbers language-text" data-language="text"><code class="language-text">SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下  META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，添加在容器中   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>将 类路径下  META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；</strong></p></blockquote><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment">#Auto Configure</span><span class="token attr-name">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span><span class="token punctuation">=</span><span class="token attr-value">\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3）、每一个自动配置类进行自动配置功能；"><a href="#3）、每一个自动配置类进行自动配置功能；" class="headerlink" title="3）、每一个自动配置类进行自动配置功能；"></a>3）、每一个自动配置类进行自动配置功能；</h3><h3 id="4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理；"><a href="#4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理；" class="headerlink" title="4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理；"></a>4）、以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>   <span class="token comment">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token class-name">HttpEncodingProperties</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>  <span class="token comment">//启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中</span><span class="token annotation punctuation">@ConditionalOnWebApplication</span> <span class="token comment">//Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是web应用，如果是，当前配置类生效</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token class-name">CharacterEncodingFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>  <span class="token comment">//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；</span><span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.http.encoding"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"enabled"</span><span class="token punctuation">,</span> matchIfMissing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token comment">//判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的</span><span class="token comment">//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpEncodingAutoConfiguration</span> <span class="token punctuation">{</span>    <span class="token comment">//他已经和SpringBoot的配置文件映射了</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">HttpEncodingProperties</span> properties<span class="token punctuation">;</span>     <span class="token comment">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span>  <span class="token keyword">public</span> <span class="token class-name">HttpEncodingAutoConfiguration</span><span class="token punctuation">(</span><span class="token class-name">HttpEncodingProperties</span> properties<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>properties <span class="token operator">=</span> properties<span class="token punctuation">;</span><span class="token punctuation">}</span>      <span class="token annotation punctuation">@Bean</span>   <span class="token comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span><span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span><span class="token class-name">CharacterEncodingFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token comment">//判断容器没有这个组件？</span><span class="token keyword">public</span> <span class="token class-name">CharacterEncodingFilter</span> <span class="token function">characterEncodingFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">CharacterEncodingFilter</span> filter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderedCharacterEncodingFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>filter<span class="token punctuation">.</span><span class="token function">setEncoding</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>properties<span class="token punctuation">.</span><span class="token function">getCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>filter<span class="token punctuation">.</span><span class="token function">setForceRequestEncoding</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>properties<span class="token punctuation">.</span><span class="token function">shouldForce</span><span class="token punctuation">(</span><span class="token class-name">Type</span><span class="token punctuation">.</span>REQUEST<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>filter<span class="token punctuation">.</span><span class="token function">setForceResponseEncoding</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>properties<span class="token punctuation">.</span><span class="token function">shouldForce</span><span class="token punctuation">(</span><span class="token class-name">Type</span><span class="token punctuation">.</span>RESPONSE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> filter<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>根据当前不同的条件判断，决定这个配置类是否生效？</p><p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p></blockquote><h3 id="5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类"><a href="#5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类" class="headerlink" title="5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类"></a>5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.http.encoding"</span><span class="token punctuation">)</span>  <span class="token comment">//从配置文件中获取指定的值和bean的属性进行绑定</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpEncodingProperties</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Charset</span> DEFAULT_CHARSET <span class="token operator">=</span> <span class="token class-name">Charset</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="精髓："><a href="#精髓：" class="headerlink" title="精髓："></a><strong>精髓：</strong></h2><h3 id="1）、SpringBoot启动会加载大量的自动配置类"><a href="#1）、SpringBoot启动会加载大量的自动配置类" class="headerlink" title="1）、SpringBoot启动会加载大量的自动配置类"></a><strong>1）、SpringBoot启动会加载大量的自动配置类</strong></h3><h3 id="2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；"><a href="#2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；" class="headerlink" title="2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；"></a><strong>2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；</strong></h3><h3 id="3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）"><a href="#3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）" class="headerlink" title="3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）"></a><strong>3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）</strong></h3><h3 id="4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；"><a href="#4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；" class="headerlink" title="4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；"></a><strong>4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；</strong></h3><blockquote><p>xxxxAutoConfigurartion：自动配置类；</p></blockquote><blockquote><p>给容器中添加组件</p></blockquote><blockquote><p>xxxxProperties:封装配置文件中相关属性；</p></blockquote><h2 id="Conditional-派生注解详解"><a href="#Conditional-派生注解详解" class="headerlink" title="@Conditional 派生注解详解"></a><strong><a href="https://songan.github.io/2019/05/18/Conditional/">@Conditional 派生注解详解</a></strong></h2>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>按周，天，月分组查询</title>
      <link href="2019/05/15/2019-05-15-week-day-monthgroupquery/"/>
      <url>2019/05/15/2019-05-15-week-day-monthgroupquery/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">--按周</span><span class="token keyword">select</span> DATE_FORMAT<span class="token punctuation">(</span>f<span class="token punctuation">.</span>upload_time<span class="token punctuation">,</span><span class="token string">'%Y%u'</span><span class="token punctuation">)</span> weeks<span class="token punctuation">,</span>        <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">sum</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>download_times<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">sum</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>collection_times<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">sum</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>click_times<span class="token punctuation">)</span>    <span class="token keyword">from</span> file_base f       <span class="token keyword">left</span> <span class="token keyword">join</span> file_property p <span class="token keyword">on</span> f<span class="token punctuation">.</span>property_id <span class="token operator">=</span> p<span class="token punctuation">.</span>id <span class="token keyword">group</span> <span class="token keyword">by</span> weeks<span class="token punctuation">;</span>          <span class="token comment">--按天 </span><span class="token keyword">select</span> DATE_FORMAT<span class="token punctuation">(</span>f<span class="token punctuation">.</span>upload_time<span class="token punctuation">,</span><span class="token string">'%Y-%m-%d'</span><span class="token punctuation">)</span> days<span class="token punctuation">,</span>        <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">sum</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>download_times<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">sum</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>collection_times<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">sum</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>click_times<span class="token punctuation">)</span><span class="token keyword">from</span> file_base f       <span class="token keyword">left</span> <span class="token keyword">join</span> file_property p <span class="token keyword">on</span> f<span class="token punctuation">.</span>property_id <span class="token operator">=</span> p<span class="token punctuation">.</span>id  <span class="token keyword">group</span> <span class="token keyword">by</span> days<span class="token punctuation">;</span>            <span class="token comment">--按月 </span><span class="token keyword">select</span> DATE_FORMAT<span class="token punctuation">(</span>f<span class="token punctuation">.</span>upload_time<span class="token punctuation">,</span><span class="token string">'%Y%m'</span><span class="token punctuation">)</span> months<span class="token punctuation">,</span>        <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">sum</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>download_times<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">sum</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>collection_times<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token function">sum</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>click_times<span class="token punctuation">)</span> <span class="token keyword">from</span> file_base f       <span class="token keyword">left</span> <span class="token keyword">join</span> file_property p <span class="token keyword">on</span> f<span class="token punctuation">.</span>property_id <span class="token operator">=</span> p<span class="token punctuation">.</span>id   <span class="token keyword">group</span> <span class="token keyword">by</span> months<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CountDownLatch 来模拟并发</title>
      <link href="2019/05/14/2019-05-13-countdownlatchtosimulateconcurrency/"/>
      <url>2019/05/14/2019-05-13-countdownlatchtosimulateconcurrency/</url>
      
        <content type="html"><![CDATA[<h2 id="CountDownLatch介绍"><a href="#CountDownLatch介绍" class="headerlink" title="CountDownLatch介绍"></a>CountDownLatch介绍</h2><p>   CountDownLatch是一个并发工具类，&nbsp;作用是允许一个或多个线程等待其他线程完成操作。</p><blockquote><p>我们有时会称之为发令枪。有一个个形象的例子能说明其功能：公司召开一个全体股东会，需要所有股东到场了才能正式开始。会议室准备了一个花名册，记录了需要到会的总人数，每一个股东来到会议室就要签名确认，同时总人数减一，当需要到会的总人数为0时，会议就正式开始。所以，CountDownLatch就有充当计数器和发令枪的功能。</p></blockquote><h2 id="模拟并发请求"><a href="#模拟并发请求" class="headerlink" title="模拟并发请求"></a>模拟并发请求</h2><p>   通过CountDownLatch的计数和发令功能，我们可以通过它模拟并发请求的功能，常常能用于测试。下面的代码时一个模拟并发请求的示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//concurrentCount 为并发量</span><span class="token keyword">final</span> <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>concurrentCount<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> concurrentCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程: "</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//使线程阻塞,等待计数器 concurrentCount 为 0 时,阻塞的线程会同时开始执行</span>            countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//测试并发需要执行的代码,或者调用方法</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//计数器减 1 </span>    countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CountDownLatch </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring单例与线程安全小结</title>
      <link href="2019/05/13/2019-05-13-spring-dan-li-mo-shi-yu-xian-cheng-an-quan/"/>
      <url>2019/05/13/2019-05-13-spring-dan-li-mo-shi-yu-xian-cheng-an-quan/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring单例模式与线程安全"><a href="#Spring单例模式与线程安全" class="headerlink" title="Spring单例模式与线程安全"></a>Spring单例模式与线程安全</h2><p>  Spring框架里的bean，或者说组件，获取实例的时候都是<strong>默认的单例模式</strong>，这是在多线程开发的时候要尤其注意的地方。</p><p> <strong>单例模式的意思就是只有一个实例。单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</strong>这个类称为单例类。<br>当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这是多个线程会并发执行该请求多对应的业务逻辑（成员方法），此时就要注意了，如果该处理逻辑中有对该单列状态的修改（体现为该单列的成员属性），则必须考虑线程同步问题<br>同步机制的比较　　ThreadLocal和线程同步机制相比有什么优势呢？ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。 </p><p>　　在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。 </p><p>　　而 <code>ThreadLocal</code> 则从另一个角度来解决多线程的并发访问。<strong>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。</strong><br>ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p><p>　　由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换。但JDK 5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用<br>　概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。 </p><p>　　Spring使用ThreadLocal解决线程安全问题 </p><p>　　我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等）中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。 </p><p>　　一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程<br>ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。<br>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。<br>或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。<br>　线程安全问题都是由全局变量及静态变量引起的。<br>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。</p><ol><li>常量始终是线程安全的，因为只存在读操作。</li><li>每次调用方法前都新建一个实例是线程安全的，因为不会访问共享的资源。</li><li>局部变量是线程安全的。因为每执行一个方法，都会在独立的空间创建局部变量，它不是共享的资源。局部变量包括方法的参数变量和方法内变量。</li></ol><p>有状态就是有数据存储功能。有状态对象(Stateful<br>Bean)，就是有实例变量的对象，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。</p><p>无状态就是一次操作，不能保存数据。无状态对象(Stateless<br>Bean)，就是没有实例变量的对象 .不能保存数据，是不变类，是线程安全的。 有状态对象:<br>无状态的Bean适合用不变模式，技术就是单例模式，这样可以共享实例，提高性能。有状态的Bean，多线程环境下不安全，那么适合用Prototype原型模式。Prototype:<br>每次对bean的请求都会创建一个新的bean实例。</p><p>Struts2默认的实现是Prototype模式。也就是每个请求都新生成一个Action实例，所以不存在线程安全问题。<font color="blue">需要注意的是，如果由Spring管理action的生命周期，<br>scope要配成prototype作用域。</font></p><h2 id="线程安全案例"><a href="#线程安全案例" class="headerlink" title="线程安全案例"></a>线程安全案例</h2><p> <code>SimpleDateFormat</code>(下面简称sdf)类内部有一个<code>Calendar</code>对象引用,它用来储存和这个sdf相关的日期信息,例如<code>sdf.parse(dateStr)</code>,<br> <code>sdf.format(date)</code> 诸如此类的方法参数传入的日期相关String, Date等等,<br> 都是交友Calendar引用来储存的.这样就会导致一个问题,如果你的sdf是个static的,<br> 那么多个thread 之间就会共享这个sdf, 同时也是共享这个Calendar引用, 并且, 观察<br> sdf.parse() 方法,你会发现有如下的调用:</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token class-name">Date</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   calendar<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 清理calendar</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// 执行一些操作, 设置 calendar 的日期什么的</span>   calendar<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取calendar的时间</span> <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 这里会导致的问题就是, 如果 线程A 调用了 sdf.parse(), 并且进行了 calendar.clear()后还未执行calendar.getTime()的时候,线程B又调用了sdf.parse(), 这时候线程B也执行了sdf.clear()方法, 这样就导致线程A的的calendar数据被清空了(实际上A,B的同时被清空了).<br> 又或者当 A 执行了calendar.clear() 后被挂起, 这时候B 开始调用sdf.parse()并顺利i结束, 这样 A 的 calendar内存储的的date 变成了后来B设置的calendar的date<br>这个问题背后隐藏着一个更为重要的问题–无状态：无状态方法的好处之一，就是它在各种环境下，都可以安全的调用。衡量一个方法是否是有状态的，就看它是否改动了其它的东西，比如全局变量，比如实例的字段。format方法在运行过程中改动了SimpleDateFormat的calendar字段，所以，它是有状态的。</p><blockquote><p>这也同时提醒我们在开发和设计系统的时候注意下一下三点:</p></blockquote><ol><li> 自己写公用类的时候，要对多线程调用情况下的后果在注释里进行明确说明</li><li> 对线程环境下，对每一个共享的可变变量都要注意其线程安全性</li><li>我们的类和方法在做设计的时候，要尽量设计成无状态的</li></ol><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="1-需要的时候创建新实例"><a href="#1-需要的时候创建新实例" class="headerlink" title="1.需要的时候创建新实例"></a>1.需要的时候创建新实例</h3><p>   <strong>说明：在需要用到SimpleDateFormat 的地方新建一个实例，不管什么时候，将有线程安全问题的对象由共享变为局部私有都能避免多线程问题，不过也加重了创建对象的负担。在一般情况下，这样其实对性能影响比不是很明显的。</strong></p><h3 id="2-使用同步：同步SimpleDateFormat对象"><a href="#2-使用同步：同步SimpleDateFormat对象" class="headerlink" title="2.使用同步：同步SimpleDateFormat对象"></a>2.使用同步：同步SimpleDateFormat对象</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//说明：当线程较多时，当一个线程调用该方法时，其他想要调用此方法的线程就要block，多线程并发量大的时候会对性能有一定的影响。</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DateSyncUtil</span> <span class="token punctuation">{</span>     <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">SimpleDateFormat</span> sdf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">formatDate</span><span class="token punctuation">(</span><span class="token class-name">Date</span> date<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">ParseException</span><span class="token punctuation">{</span>        <span class="token keyword">synchronized</span><span class="token punctuation">(</span>sdf<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> sdf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Date</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token class-name">String</span> strDate<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ParseException</span><span class="token punctuation">{</span>        <span class="token keyword">synchronized</span><span class="token punctuation">(</span>sdf<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> sdf<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>strDate<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-使用ThreadLocal"><a href="#3-使用ThreadLocal" class="headerlink" title="3.使用ThreadLocal"></a>3.使用ThreadLocal</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentDateUtil</span> <span class="token punctuation">{</span>     <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DateFormat</span><span class="token punctuation">&gt;</span></span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DateFormat</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token class-name">DateFormat</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Date</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token class-name">String</span> dateStr<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ParseException</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>dateStr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">Date</span> date<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>或者</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//说明：使用ThreadLocal, 也是将共享变量变为独享，线程独享肯定能比方法独享在并发环境中能减少不少创建对象的开销。如果对性能要求比较高的情况下，一般推荐使用这种方法。</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalDateUtil</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> date_format <span class="token operator">=</span> <span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DateFormat</span><span class="token punctuation">&gt;</span></span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DateFormat</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">DateFormat</span> <span class="token function">getDateFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">{</span>          <span class="token class-name">DateFormat</span> df <span class="token operator">=</span> threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>df<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              df <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span>date_format<span class="token punctuation">)</span><span class="token punctuation">;</span>              threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>df<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">return</span> df<span class="token punctuation">;</span>      <span class="token punctuation">}</span>       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">formatDate</span><span class="token punctuation">(</span><span class="token class-name">Date</span> date<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ParseException</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getDateFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Date</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token class-name">String</span> strDate<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ParseException</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getDateFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>strDate<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-抛弃JDK，使用其他类库中的时间格式化类"><a href="#4-抛弃JDK，使用其他类库中的时间格式化类" class="headerlink" title="4.抛弃JDK，使用其他类库中的时间格式化类"></a>4.抛弃JDK，使用其他类库中的时间格式化类</h3><ol><li>   使用Apache commons 里的FastDateFormat，宣称是既快又线程安全的SimpleDateFormat, 可惜它只能对日期进行format, 不能对日期串进行解析。</li><li>   使用Joda-Time类库来处理时间相关问题</li></ol><blockquote><p>做一个简单的压力测试，方法一最慢，方法三最快，但是就算是最慢的方法一性能也不差，一般系统方法一和方法二就可以满足，所以说在这个点很难成为你系统的瓶颈所在。从简单的角度来说，建议使用方法一或者方法二，如果在必要的时候，追求那么一点性能提升的话，可以考虑用方法三，用ThreadLocal做缓存。</p></blockquote><blockquote><p><strong>Joda-Time类库对时间处理方式比较完美，建议使用。</strong></p></blockquote><blockquote><p><strong>原文地址:</strong> <a href="https://www.cnblogs.com/doit8791/p/4093808.html">Spring单例与线程安全小结</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7安装Docker</title>
      <link href="2019/05/12/2019-05-12-centos7-an-zhuang-docker/"/>
      <url>2019/05/12/2019-05-12-centos7-an-zhuang-docker/</url>
      
        <content type="html"><![CDATA[<h2 id="centOS7安装Docker之前需要CentOS7-内核高于-3-1"><a href="#centOS7安装Docker之前需要CentOS7-内核高于-3-1" class="headerlink" title="centOS7安装Docker之前需要CentOS7 内核高于 3.1"></a>centOS7安装Docker之前需要CentOS7 内核高于 3.1</h2><p><code>uname -r</code></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8g66cwvaaj308i018dfm.jpg" alt="CentOS7 内核"></p><p> 假如版本太低可以使用</p><p><code>yum update #升级内核版本</code></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载命令:<br><code>yum install docker</code></p><p>下载完成提示输入 Y/N，输入 Y 开始安装。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p><code>systemctl start docker</code><br> 报错:</p><pre class="line-numbers language-none"><code class="language-none">Job for docker.service failed because the control process exited with error code. See "systemctl status docker.service" and "journalctl -xe" for details.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改 <em>/etc/sysconfig/docker</em> 文件</p><p><img src="!%5B%5D(https://tva1.sinaimg.cn/large/006y8mN6ly1g8g67wci02j31gg0onac2.jpg" alt="报错"></p><p><code>vi /etc/sysconfig/docker</code></p><p>保存退出<br>重新启动 docker</p><p><code>systemctl start docker</code><br>    启动完成不在报错</p><p>   查看docker进程</p><p>   <img src="!%5B%5D(https://tva1.sinaimg.cn/large/006y8mN6ly1g8g688cdl5j316s04kgm1.jpg" alt="docker进程"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOs </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iframe跨域传递参数</title>
      <link href="2019/05/12/2019-05-12-iframe-kua-yu-chuan-di-can-shu/"/>
      <url>2019/05/12/2019-05-12-iframe-kua-yu-chuan-di-can-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="子页面（iframe引入的页面）"><a href="#子页面（iframe引入的页面）" class="headerlink" title="子页面（iframe引入的页面）"></a>子页面（iframe引入的页面）</h3><p><code>window.parent.postMessage({eventId:data.eventId},'*');</code><br>postMessage的参数：</p><p>  <strong>第一个:要传递的数据，可以是字符串，可以是对象。</strong></p><p>  <strong>第二个:通知给哪个源下面的资源，比如“<a href="https://www.sazyj.cn”,则只有父页面在次源下才能接收到这个数据/">https://www.sazyj.cn”,则只有父页面在次源下才能接收到这个数据</a></strong></p><h3 id="父页面"><a href="#父页面" class="headerlink" title="父页面"></a>父页面</h3><pre class="line-numbers language-none"><code class="language-none">window.addEventListener('message', function (e) {    console.log(e.target.data);},false);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下nfs共享服务器的安装</title>
      <link href="2019/05/12/2019-05-12-linux-xia-nfs-gong-xiang-fu-wu-qi-de-an-zhuang/"/>
      <url>2019/05/12/2019-05-12-linux-xia-nfs-gong-xiang-fu-wu-qi-de-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h3 id="检查共享端，即需要提供分享文件夹的服务器是否具有NFS服务"><a href="#检查共享端，即需要提供分享文件夹的服务器是否具有NFS服务" class="headerlink" title="检查共享端，即需要提供分享文件夹的服务器是否具有NFS服务"></a>检查共享端，即需要提供分享文件夹的服务器是否具有NFS服务</h3><p><code>rpm -qa |grep nfs</code></p><p>如果安装了，则会打印一些信息,否则什么也不会发生，就需要安装了</p><p>使用root权限</p><p><code>yum install nfs-utils</code></p><h3 id="修改共享端中的-etc-exports-文件本来应该是空的"><a href="#修改共享端中的-etc-exports-文件本来应该是空的" class="headerlink" title="修改共享端中的/etc/exports(文件本来应该是空的)"></a>修改共享端中的/etc/exports(文件本来应该是空的)</h3><p> <code>/DATA/share 192.168.1.1(rw,no_root_squash,async)</code></p><p>这个配置表示开放本地存储目录 <em>/DATA/share</em> 只允许 <em>192.168.1.1</em> 这个主机有访问权限，<font color="red"> rw </font> 表示允许读写；<font color="red">no_root_squash</font> 表示 root 用户具有完全的管理权限；<font color="red">no_all_squash</font>表示保留共享文件的UID和GID，此项是默认不写也可以；<font color="red"> async </font>表示数据可以先暂时在内存中，不是直接写入磁盘，可以提高性能，另外也可以配置sync表示数据直接同步到磁盘；就配置这些就可以，保存退出</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p> 1.<code>service rpcbind start</code></p><p> 2.<code>chkconfig rpcbind on</code></p><p> 3.<code>service nfs start</code></p><h3 id="客户端-需要挂载的一端"><a href="#客户端-需要挂载的一端" class="headerlink" title="客户端(需要挂载的一端)"></a>客户端(需要挂载的一端)</h3><p>也必须安装nfs服务</p><p>执行</p><p><code>mount -t nfs 10.221.149.15:/DATA/share2  /DATA/share2</code></p><p>*df -h *可以查看挂载</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> NFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot在tomcat中启动两次的问题</title>
      <link href="2019/05/12/2019-05-12-springboot-zai-tomcat-zhong-qi-dong-liang-ci-de-wen-ti/"/>
      <url>2019/05/12/2019-05-12-springboot-zai-tomcat-zhong-qi-dong-liang-ci-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="有两个可能性的"><a href="#有两个可能性的" class="headerlink" title="有两个可能性的"></a>有两个可能性的</h1><p>1.springboot 的内置tomcat没有去掉，导致springboot 和tomcat 分别启动了1次</p><p>2.完全是tomcat 启动了两次</p><h2 id="第一个问题：我们在springboot-pom-xml中"><a href="#第一个问题：我们在springboot-pom-xml中" class="headerlink" title="第一个问题：我们在springboot pom.xml中"></a>第一个问题：我们在springboot pom.xml中</h2><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">&gt;</span></span>war<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 去除内嵌tomcat --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-tomcat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!--添加servlet的依赖--&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>javax.servlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>javax.servlet-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>provided<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第二个问题：在tomcat-的server-xml中-把host的appBase-换为“”，然后启动就好了"><a href="#第二个问题：在tomcat-的server-xml中-把host的appBase-换为“”，然后启动就好了" class="headerlink" title="第二个问题：在tomcat 的server.xml中 把host的appBase 换为“”，然后启动就好了"></a>第二个问题：在tomcat 的server.xml中 把host的appBase 换为“”，然后启动就好了</h2><p>或者你在tomcat内部新建一个webroot 文件夹 然后把appBase换成webroot 也可以</p><p>就是host 和context 分别启动了两次</p><p>当时看到这的时候以为肯定是这两个问题，一定能解决，结果我们改完之后，测试还是不好使<br>然后经过测试</p><p>发现是springboot 启动类 <code>@SpringBootApplication</code>的类 把 <code>extends</code> 的去掉就好了</p><p>具体原因就不在这里说明了，但是基本上 springboot 在 tomcat 中发布两次的问题 就这三个原因了</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux服务器之间传输文件</title>
      <link href="2019/05/10/2019-05-10-linux-scp/"/>
      <url>2019/05/10/2019-05-10-linux-scp/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器之间传输文件"><a href="#服务器之间传输文件" class="headerlink" title="服务器之间传输文件"></a>服务器之间传输文件</h2><blockquote><p>这是我的第一篇博客。</p></blockquote><h3 id="需要在A服务器传输到B服务器"><a href="#需要在A服务器传输到B服务器" class="headerlink" title="需要在A服务器传输到B服务器"></a>需要在A服务器传输到B服务器</h3><p><strong>在A服务器执行命令</strong><br><code>scp 需要传输的文件  B服务器的登录账户@B服务器的地址:需要保存在B服务器的目录</code></p><p>如：</p><p><code>scp test.war root@192.168.1.51:/data</code></p><p> <strong>提示输入B服务器的密码,输入密码回车后开始传输</strong></p><p> 如需传输文件夹,需要加上 -r</p><p> <code>scp -r test root@192.168.1.51:/data</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装redis 完整步骤</title>
      <link href="2019/05/10/2019-05-10-linux-an-zhuang-redis-wan-zheng-bu-zou/"/>
      <url>2019/05/10/2019-05-10-linux-an-zhuang-redis-wan-zheng-bu-zou/</url>
      
        <content type="html"><![CDATA[<h2 id="获取redis资源"><a href="#获取redis资源" class="headerlink" title="获取redis资源"></a>获取redis资源</h2><p><code>wget http://download.redis.io/releases/redis-4.0.8.tar.gz</code></p><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p><code>tar xzvf redis-4.0.8.tar.gz</code></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd redis-4.0.8makecd srcmake install PREFIX=/usr/local/redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="移动配置文件到安装目录下"><a href="#移动配置文件到安装目录下" class="headerlink" title="移动配置文件到安装目录下"></a>移动配置文件到安装目录下</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd ../mkdir /usr/local/redis/etcmv redis.conf /usr/local/redis/etc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置redis为后台启动"><a href="#配置redis为后台启动" class="headerlink" title="配置redis为后台启动"></a>配置redis为后台启动</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vi /usr/local/redis/etc/redis.conf #将daemonize no 改成daemonize yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="将redis加入到开机启动"><a href="#将redis加入到开机启动" class="headerlink" title="将redis加入到开机启动"></a>将redis加入到开机启动</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#意思就是开机调用这段开启redis的命令 vi /etc/rc.local #在里面添加内容： /usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="开启redis"><a href="#开启redis" class="headerlink" title="开启redis"></a>开启redis</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3></blockquote><p>　　</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">//启动redisredis-server /usr/local/redis/etc/redis.conf pkill redis  //停止redis卸载redis：rm -rf /usr/local/redis //删除安装目录rm -rf /usr/bin/redis-* //删除所有redis相关命令脚本rm -rf /root/download/redis-4.0.4 //删除redis解压<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOs </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
